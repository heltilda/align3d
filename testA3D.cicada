tester :: aligner3d




| test 1:  compare the 1-pass partition function (i.e. without iterating on the spot penalties) with a brute-force calculation


p1 :: p2 :: pdiff :: analyticGrad :: numericalGrad :: [] double
rtrn :: *

print("1-pass test:  ")

tester.loadExperiment("test1loci.txt", "test1spots.txt")

tester.restart(; p_fn = 0, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0)

rtrn = @tester.iterate(0)
p1[*] =! tester.p

rtrn = @tester.iterate(0; calcExact = true)
p2[*] =! tester.p

pdiff[^top(p1)]
for c1 in <1, top(p1)>  pdiff[c1] = abs(p2[c1] - p1[c1])

if max(pdiff) > 1.e-12  then (
    printl(" ********** error!! **********")
    return      )

printl("passed!")





| test 2:  compare the analytical and numerical gradients of the cost function


print("gradient test:  ")

eps := 1.e-8

tester.loadExperiment("test2loci.txt", "test2spots.txt")

tester.restart(; p_fn = 0.2, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0, n_skip_max = 3)

for c1 in <1, top(tester.overlapField)>  tester.overlapField[c1] = 5*random()-2

rtrn = @tester.iterate(0)
C0 := tester.iterate.C_history[1][1]
analyticGrad[*] =! tester.gradOverlapField

numericalGrad[^top(tester.overlapField)]

for c1 in <1, top(tester.overlapField)>  (
    tester.overlapField[c1] = that + eps
    
    rtrn = @tester.iterate(0)
    numericalGrad[c1] = (tester.iterate.C_history[1][1] - C0) / eps
    
    tester.overlapField[c1] = that - eps
)

pdiff[^top(analyticGrad)]
for c1 in <1, top(pdiff)>  pdiff[c1] = abs(analyticGrad[c1] - numericalGrad[c1])

if max(pdiff) > eps^.5  then (
    printl(" ********** error!! **********")
    return      )

printl("passed!")





| test 3:  make sure that iteration minimizes the cost function


print("convergence test:  ")

rtrn = @tester.iterate(100)

if tester.iterate.C_history[top][1] > 10^-4*C0 and abs(tester.iterate.C_history[top][1]-tester.iterate.C_history[top-1][1]) > 1.e-3  then (
    printl(" ********** error!! **********")
    return      )

printl("passed!")
