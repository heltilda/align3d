tester :: aligner3d
randSpot :: loopFix :: loopFixedLocus :: loopPass :: loopMP :: loopColor :: loopLocus :: loopSpot :: loopElement :: looptf :: int
spotsToFix :: [] int
p1 :: p2 :: pdiff :: analyticGrad :: numericalGrad :: holdF :: holdW :: [] double
wereFixed :: [] bool
rtrn :: *
repeatExactCalc := false
dpVals :: { 0, size(double) }
dpStrings :: { "dp ", "mp " }

tester.loadExperiment("test_loci.txt", "test_spots.txt")



passString := ""
for loopPass in <1, 4>  (
for loopMP in <1, 2>  (
    
    
    
        | test 1:  compare the 1-pass partition function (i.e. without iterating on the spot penalties) with a brute-force calculation
    
    
    print("1-pass ", passString, dpStrings[loopMP], "test:  ")
    
    tester.restart(; p_fp = 0.1, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0)
    for loopColor in <1, tester.numColors>  tester.nlog_w[loopColor] = that + 2*random()-1
    
    rtrn = @tester.iterate(0; doublePrecision = dpVals[loopMP])
    p1[*] =! tester.p
    iteratedLogZ := { min(tester.logZ), max(tester.logZ) }
    
    rtrn = @tester.iterate(0; byEnumeration = true, calcExact = false, doublePrecision = dpVals[loopMP])
    p2[*] =! tester.p
    
    pdiff[^top(p1)]
    for c1 in <1, top(p1)>  pdiff[c1] = abs(p2[c1] - p1[c1])
    
    if max(p1) == 0 and max(p2) == 0  then printl("passed, ** trivially **")
    else if max(pdiff) > 1.e-10 or abs(tester.logZ[1] - iteratedLogZ[1]) > 1.e-12*abs(tester.logZ[1]) &
                or abs(tester.logZ[1] - iteratedLogZ[2]) > 1.e-12*abs(tester.logZ[1])  then (
        printl(" ********** error!! **********")
        return      )
    else  printl("passed!")
    
    
    
    
    
        | test 2:  compare the analytical and numerical gradients of the cost function
    
    
    print(passString, dpStrings[loopMP], "gradient test:  ")
    
    optAlg := 3
    eps := 1.e-8
    
    tester.restart(; p_fp = 0.2, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0, n_skip_max = 3)
    
    if loopMP == 1  then (
        for c1 in <1, tester.numSpots>  tester.nlog_f[c1] = 5*random()-2
        for c1 in <1, tester.numColors>  tester.nlog_w[c1] = 5*random()-2
        holdF[] = tester.nlog_f[]
        holdW[] = tester.nlog_w[]    )
    else  (
        tester.nlog_f[] = holdF[]          | restart() resets f and w
        tester.nlog_w[] = holdW[]  )
    
    C0 := tester.iterate(0; setUnboundPenalty = false, doublePrecision = dpVals[loopMP])[2][1]
    analyticGrad[] = tester.grad_fw[]
    rtrn = @tester.iterate(0; setUnboundPenalty = true, doublePrecision = dpVals[loopMP])
    analyticGrad[+<top+1, top+tester.numColors>] = tester.grad_fw[]
    
    numericalGrad[^top(analyticGrad)] = 0
    
    for c1 in <1, tester.numSpots+tester.numColors>  (     | was 2
        
        for c2 in <-1, 1>  (
        if c2 /= 0  then (
            
            if c1 <= tester.numSpots  then tester.nlog_f[c1] = that + c2*eps
            else  tester.nlog_w[c1-tester.numSpots] = that + c2*eps
            
            if c1 <= tester.numSpots  then &
                numericalGrad[c1] = that + c2 * tester.iterate(0; optMethod = optAlg, doublePrecision = dpVals[loopMP])[2][1] / (2*eps)
            else  &
                numericalGrad[c1] = that + c2 * tester.iterate(0; optMethod = optAlg, setUnboundPenalty = true, doublePrecision = dpVals[loopMP])[2][1] / (2*eps)
            
            if c1 <= tester.numSpots  then tester.nlog_f[c1] = that - c2*eps
            else  tester.nlog_w[c1-tester.numSpots] = that - c2*eps
    )   ))
    
    pdiff[^top(analyticGrad)]
    for c1 in <1, top(pdiff)>  pdiff[c1] = abs(analyticGrad[c1] - numericalGrad[c1])
    
    if min(analyticGrad) == 0 and min(numericalGrad) == 0 and max(analyticGrad) == 0 and max(numericalGrad) == 0  then printl("passed, ** trivially **")
    else if max(pdiff) > eps^.5 * max(-min(analyticGrad), max(analyticGrad), 1)  then (
        printl(" ********** error!! **********")
        return      )
    else  printl("passed!")
    
    
    
    
    
        | test 3:  make sure that iteration minimizes the cost function -- this sometimes fails just because the optimizer doesn't find it
    
    
    if min(p1) > 0.  then (
        
        optimizationMethod := 3
        for c1 in <1, 2>  (
            
            print(passString, dpStrings[loopMP], "convergence test ", c1, ":  ")

            tester.restart()
            rtrn = @tester.iterate(100; doublePrecision = dpVals[loopMP], optMethod = optimizationMethod, preOptimize = false)

            if tester.iterate.C_history[top][1] > 10^-4*C0 and abs(tester.iterate.C_history[top][1]-tester.iterate.C_history[top-1][1]) > 1.e-3  then &
                printl(" *** didn't converge **")
            else  printl("passed!")
            
            optimizationMethod = 0
    )   )
    
    


        | fix random spots, then repeat all the tests
    
    if loopMP == 2  then (
        
        if loopPass > 1  then tester.addZterm(random())     | (2*random()-1) -- can lead to negative probabilities that can't be cured by any choice of f/w
        
        wereFixed[^tester.numLoci] = false
        for loopColor in <0, tester.numColors>  (
            locusFixProb := 0.5*random()
            spotsToFix[^0]
            
            for loopFixedLocus in <1, tester.numLoci>  (
            if (loopColor == 0 or tester.loci[loopFixedLocus].color+1 == loopColor) and random() < locusFixProb and not wereFixed[loopFixedLocus]  then (
                spotsToFix[+top+1] = loopFixedLocus
                if loopColor == 0  then wereFixed[loopFixedLocus] = true
            ))
            
            if loopColor == 0  then &
                tester.fix(spotsToFix, *)
            else if top(spotsToFix) > 0  then (
                loop  randSpot = ceil(tester.numSpots*random())  until tester.spots[randSpot].color+1 == loopColor
                tester.fix(spotsToFix, randSpot)
        )   )
        
        if loopPass == 1  then passString = "fixed "
        else  passString = cat(loopPass, "-term ")
))  )



    | test that the exact partition function calculation matches its series expansion


locusList :: [] int

findOverlappingSets :: {
    
    nextFindOverlappingSets :: *
    doNextLocus :: bool
    
    code
    
    if args[1] > numEachColor[loopColor]  then (
        if top(locusList) > 1  then (
            overlappingSubsets[loopColor][+top+1] :: [] int
            overlappingSubsets[loopColor][top][] = locusList[]   )
        return      )
    
    if nextFindOverlappingSets == @nothing  then nextFindOverlappingSets :: this
    
    nextFindOverlappingSets(args[1]+1)
    
    doNextLocus = true
    if top(locusList) > 0  then (
    if locusList[top]+1 == colorIDs[loopColor][args[1]]  then (
        doNextLocus = false
    ))
    
    if doNextLocus  then  (
        locusList[+top+1] = colorIDs[loopColor][args[1]]
        nextFindOverlappingSets(args[1]+1)
        locusList[^top-1]   )
}


    | addOverlapSpot() explicitly builds the terms for series #1

addOverlapSpot :: {
    
    loopOverlapSet :: numSubsets :: numLociInSubset :: oneColor :: loopSpot :: loopColoredSpot :: loopLocus :: numSubsetsUsed :: int
    isFree :: bool
    oneOverlappingSubset :: *
    
    
    code
    
    if spotNo > tester.numSpots  then (
        
        numSubsetsUsed = 0
        for loopSpot in <1, tester.numSpots>  (
        if spotOverlapSubsets[loopSpot] > 0  then (
            numSubsetsUsed = that + 1
        ))
        
        tester.addZterm(-1^numSubsetsUsed)
        
        for loopSpot in <1, tester.numSpots>  (
        if spotOverlapSubsets[loopSpot] > 0  then (
            oneColor = tester.spots[loopSpot].color + 1
            tester.fix(overlappingSubsets[oneColor][spotOverlapSubsets[loopSpot]], loopSpot)
        ))
        
        return
    )
    
    addOverlapSpot()
    
    oneColor = tester.spots[spotNo].color + 1
    numSubsets = top(overlappingSubsets[oneColor])
    for loopOverlapSet in <1, numSubsets>  (
        oneOverlappingSubset = @overlappingSubsets[oneColor][loopOverlapSet]
        numLociInSubset = top(oneOverlappingSubset)
        
        isFree = true
        for loopLocus in <1, numLociInSubset>  (
        if not locusMask[oneOverlappingSubset[loopLocus]]  then (
            isFree = false
        ))
        
        if isFree  then (
            spotOverlapSubsets[spotNo] = loopOverlapSet
            for loopLocus in <1, numLociInSubset>  (
                locusMask[oneOverlappingSubset[loopLocus]] = false      )
            
            addOverlapSpot()
            
            spotOverlapSubsets[spotNo] = 0
            for loopLocus in <1, numLociInSubset>  (
                locusMask[oneOverlappingSubset[loopLocus]] = true
    )   )   )
    
    oneOverlappingSubset = @nothing
    
    
    code
    
    spotNo := args[1]
    if spotNo <= tester.numSpots  then (addOverlapSpot :: this)#2(spotNo+1)
}
addOverlapSpot#2(1)


colorIDs :: overlappingSubsets :: {}
numEachColor :: [tester.numColors] int
spotOverlapSubsets :: [tester.numSpots] int
locusMask :: [tester.numLoci] bool

Z_test_no := 1
loop  (
    for loopColor in <1, tester.numColors>  colorIDs[loopColor] :: [] int
    for loopLocus in <1, tester.numLoci>  colorIDs[tester.loci[loopLocus].color+1][+top+1] = loopLocus
    for loopColor in <1, tester.numColors>  numEachColor[loopColor] = top(colorIDs[loopColor])
    
    for loopColor in <1, tester.numColors>  (
        overlappingSubsets[loopColor] :: {}
        overlappingSubsets[loopColor][^0]           | for subsequent iterations of the loop
        findOverlappingSets(1)      )
    
    for loopMP in <1, 2>  (
        
        print("exact ", dpStrings[loopMP], "Z test #", Z_test_no, ":  ")
        
        tester.free(; completely = true)
        spotOverlapSubsets[] = 0
        locusMask[] = true
        addOverlapSpot(1)
        
        tester.restart(; p_fp = 0.1, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0, avoidFixedOverlaps = true)
        
        rtrn = @tester.iterate(0; doublePrecision = dpVals[loopMP])
        p1[*] =! tester.p
        
        rtrn = @tester.iterate(0; byEnumeration = true, doublePrecision = dpVals[loopMP])
        p2[*] =! tester.p
        
        pdiff[^top(p1)]
        for c1 in <1, top(p1)>  pdiff[c1] = abs(p2[c1] - p1[c1])
        
        if max(pdiff) > 1.e-12  then (
            printl(" ********** error!! **********")
            return      )
        
        printl("passed!")
        
        
        truefalse :: { true, false }
        for looptf in <1, 2>  (
            
            print("exact Z-series ", dpStrings[loopMP], "test #", Z_test_no, " for avoidFixedOverlaps = ", truefalse[looptf], ":  ")
            
            tester.restart(; p_fp = 0.1, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0, avoidFixedOverlaps = truefalse[looptf])
            rtrn = @tester.iterate(0; doublePrecision = dpVals[loopMP])
            
            tester.setZSeries(; maxOverlaps = 1e4)
            
            tester.restart(; p_fp = 0.1, l_num = 1, l_step = 1000, neighbor_p_cutoff = 0, avoidFixedOverlaps = truefalse[looptf])
            
            rtrn = @tester.iterate(0; doublePrecision = dpVals[loopMP])
            p1[*] =! tester.p
            
            pdiff[^top(p1)]
            for c1 in <1, top(p1)>  pdiff[c1] = abs(p2[c1] - p1[c1])
            
            if max(pdiff) > 1.e-12  then (
                printl(" ********** error!! **********")
                return      )
            
            printl("passed!")
    )   )
    
    
    for loopLocus in <1, tester.numLoci>  tester.loci[loopLocus].color = floor(tester.numColors*random())
    for loopSpot in <1, tester.numSpots>  tester.spots[loopSpot].color = floor(tester.numColors*random())
    tester(tester.numLoci, tester.numSpots, tester.numColors)
    tester#2()
    
    Z_test_no = that + 1
    
)  until not repeatExactCalc

