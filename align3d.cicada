if trap(MonteCarloDefined = that) /= passed  then run("MonteCarlo.cicada")


l_bp := 0.3         | base pair length in nm

path := "/Users/brianross/Desktop/align3d/Results/"
fullPath :: { fp :: string; print_string(fp, path, args), return new(fp) }


locus :: {
    l :: double
    color :: int      }

spot :: {
    x :: y :: z :: dx :: dy :: dz :: double
    color :: int          }




| ************************************** aligner3d class **************************************
| 
| aligner3d is used to perform conformational reconstructions using a set of loci along with a spot 'image' (set of 3D positions and colors).
| 
| typical usage:
| 
| aligner3d.loadExperiment("myloci.txt", "myimage.txt")     | loads the data files
| aligner3d.restart()                                       | begins a reconstruction
| aligner3d.iterate(100)                                    | iterates the align3d algorithm to (hopefully) a solution


aligner3d :: {
    
    loci :: [] locus
    spots :: [] spot
    
    colorRange :: [] { low :: high :: int }
    
    p :: Z_1x :: Z_xN :: sensitivity :: neighbors :: [] string
    overlapField :: gradOverlapField :: Z_1x_norm :: Z_xN_norm :: Z :: dC_dZ :: sensitivity_norm :: sumLocusProbs :: sumSpotProbs :: [] double
    mask :: [] int
    
    lp :: p_fn :: p_fp :: exaggeration :: l_step :: double
    current_color :: l_num :: cs :: int
    
    chain_loaded := done_restart := false
    
    
    loadExperiment :: {
        
        lociFileName :: imageFileName :: lociFileString :: imageFileString :: string
        
        code
        
        if trap( { lociFileName, imageFileName } = args ) /= passed  then (
            printl("usage:  loadExperiment(loci filename, image_spots filename)")
            return      )
        
        if trap(lociFileString = Load(lociFileName)) /= passed  then (
            printl("aligner3d.loadExperiment() error:  file ", lociFileName, " could not be found or opened")
            return      )
        if trap(imageFileString = Load(imageFileName)) /= passed  then (
            printl("aligner3d.loadExperiment() error:  file ", imageFileName, " could not be found or opened")
            return      )
        
        readTable(loci, lociFileString)
        if readTable.errCode /= passed  then (
            printl("aligner3d.loadExperiment() error reading loci file")
            parent(0, 0, 0)
            return      )
        
        readTable(spots, imageFileString)
        if readTable.errCode /= passed  then (
            printl("aligner3d.loadExperiment() error reading image spots file")
            parent(0, 0, 0)
            return      )
        
        parent(top(loci), top(spots), max( max(loci[*].color), max(spots[*].color) ) + 1)
        parent#2()
        
        chain_loaded = true
        done_restart = false
    }
    
    
    getNeighbors :: {
        
        params :: { l_num :: int, neighbor_p_cutoff :: double }
        
        code
        
        if trap(
            if top(args) /= 1  then throw(1)
            l_step = args[1]
            (params << ( { code, l_num = 10, neighbor_p_cutoff = .001 } : args))()
        ) /= passed  then (  printl("usage: aligner3d.getNeighbors(l_step [; l_num/neighbor_p_cutoff = values])"), return  )
        
        l_num = params.l_num
        neighbors[^numSpots*numColors*params.l_num]
        
        call("GetNeighbors", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz,
                colorRange, neighbors, l_step, params.neighbor_p_cutoff, lp)
    }
    
    
    scramble :: {
        
        scrambledSpots :: [*] { color :: int, rnd :: double }
        this.c1 :: int
        
        code
        
        scrambledSpots[^numSpots]
        scrambledSpots[*].color = spots[*].color
        
        for c1 in <1, numSpots>  &
            scrambledSpots[c1].rnd = random()

        sort(scrambledSpots, 2)
        
        spots[*].color = scrambledSpots[*].color
        parent#2()
    }
    
    
    restart :: {
        
        initProbs :: initF :: [] double
        w_bar :: double
        color_counter :: loopLocus :: loopSpot :: region_counter :: IP_counter :: IP_top :: num_regions :: CsNum :: init_counter :: int
        
        params :: {
            l_num :: l_step :: int
            n_skip_max :: int
            neighbor_p_cutoff :: n_skip_p_cutoff :: search_w_step :: set_w_tol :: double
            if_set_w :: bool        }

        params.lp := @lp, params.p_fn := @p_fn, params.p_fp := @p_fp

        params.initRegions :: {

            num_regions :: c1 :: int
            
            code
            
            num_regions = top(args)
            params.regions :: {}
            
            for c1 in <1, num_regions>  (
                params.regions[c1][1] := args[c1]
                if args[c1] < 2*lp  then params.regions[c1][2] := args[c1]
                else  params.regions[c1][2] := (2*lp*args[c1])^.5
                params.regions[c1][3] := (4/3)*pi*params.regions[c1][2]^3       )
        }
        
        region :: {  R_contour_length :: R_image_radius :: R_image_volume :: double  }     | was ':: region : {'
        regions :: [] region


        code
        
        if not chain_loaded  then (
            printl("Can't run restart() before loading a chain")
            return      )
        
        trap(remove params.Log)
        
        p_fn = p_fp = -1
        
        if trap( ;
            if top(args) /= 0  then exit
            
            lp = 50/.3, p_fp = 0
            params.if_set_w = false
            (params << ( { code, trap(remove regions), l_num = 10, l_step = 200, neighbor_p_cutoff = 1.e-5,
                        n_skip_p_cutoff = .01, n_skip_max = -1, fn_cost = 1, search_w_step = 1, set_w_tol = 1.e-2 }))()
            (params<<args)()
            
            if trap(
                num_regions = top(params.regions) + 1
                regions[^num_regions-1]
                regions = params.regions
                regions[+1] = { 0, 0, 0 }
            ) /= passed   then (
                num_regions = 1
                regions[^1] = { { 0, 0, 0 } }
        )   ) /= passed  then (
            printl("usage: aligner3d.restart([; lp/l_num/l_step/neighbor_p_cutoff/p_fn/p_fp/fn_cost/n_skip_p_cutoff/n_skip_max/",
                   "if_set_w/search_w_step/set_w_tol = values][, regions[*] :: {R_contour_length/R_image_radius/R_image_volume} ",
                   "or initRegions(R1, R2, ...)]  [, Log := @Z_1x/p/...])")
            return      )
        
        l_step = params.l_step
        
        if p_fn < 0 and p_fp < 0  then p_fp = 0
        
        if p_fn >= 0 and numSpots < (1 - p_fn) * numLoci  then &
            p_fn = 1 - numSpots/numLoci
        if p_fp >= 0 and numLoci < (1 - p_fp) * numSpots  then &
            p_fp = 1 - numLoci/numSpots
        
        if p_fn >= 0  then &
            p_fp = ( numSpots - (1 - p_fn) * numLoci ) / numSpots
        else  &
            p_fn = ( numLoci - (1 - p_fp) * numSpots ) / numLoci

        if p_fn < 0  then p_fn = 0
        else if p_fn > 1  then p_fn = 1

        if p_fp < 0  then p_fp = 0
        else if p_fp > 1  then p_fp = 1

        if params.n_skip_max >= 0  then &
            iterate.n_skip_max = params.n_skip_max
        else if p_fn > 0  then &
            iterate.n_skip_max = ceil(log(params.n_skip_p_cutoff) / log(p_fn))
        else  &
            iterate.n_skip_max = 0

        for loopSpot in <1, numSpots>  &
            sumSpotProbs[loopSpot] = overlapField[loopSpot] = gradOverlapField[loopSpot] = 0

        overlapField[numSpots+1] = gradOverlapField[numSpots+1] = 0
        
        for color_counter in <0, numColors-1>  (
            IP_top = colorRange[color_counter+1].high - colorRange[color_counter+1].low + 1
            initProbs[^IP_top], initF[^IP_top]
            for IP_counter in <1, IP_top>  (
                initF[IP_counter] = 1
                initProbs[IP_counter] = (1 - p_fn) / IP_top     )

            CsNum = 0
            for loopLocus in <1, numLoci>  (
            if loci[loopLocus].color == color_counter  then (
                p[loopLocus] =! initProbs
                sumLocusProbs[loopLocus] = 1 - p_fn
                CsNum = that + 1
            ))
            
            for IP_counter in <1, IP_top>  (
                sumSpotProbs[colorRange[color_counter+1].low + IP_counter - 1] = that + CsNum * initProbs[IP_counter]
        )   )
        
        Z_xN = Z_1x = sensitivity = p
        
        for loopLocus in <1, numLoci>  (
            Z[loopLocus] = dC_dZ[loopLocus] = 0
            Z_1x_norm[loopLocus] = Z_xN_norm[loopLocus] = sensitivity_norm[loopLocus] = 0     )
        
        l_num = params.l_num
        neighbors[^numSpots*numColors*params.l_num]
        
        call("GetNeighbors", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz,
                colorRange, neighbors, l_step, params.neighbor_p_cutoff, lp)
        
        (iterate.params << {
            code
            { step_size, exaggeration, line_min_param, max_convergence, opt_method } = { .01, 1, .1, .001, 3 }
        })()
        iterate.cum_iters = 0
        w_bar = 1
        
        iterate.if_log = false
        if trap( params.Log ) == passed  then (
            printl("*** Warning -- logging ***")
            iterate.if_log = true
            trap(remove iterate.Log)
            iterate.Log :: [0] [size(params.Log)/size(double)] double     )
        else  (
            trap(remove params.Log), trap(remove iterate.Log)
            params.Log :: iterate.Log :: [][] double     )

        iterate.C_history[^0]
        
        if params.if_set_w  then (
        for init_counter in <1, 2>  (
            
            overlapField[numSpots + 1] = optimize_1D(
                {
                    code
                    
                    overlapField[numSpots + 1] = args[1]
                    iterate(0; f_or_w = w)
                    
                    return occupancy() - (1 - p_fn)
                }
                
               code
               
               search_step = params.search_w_step
               tol = params.set_w_tol
               min = -1000, max = 1000      )
            
|*            if init_counter == 1  then (
                iterate.params.end_factor = optimize_1D(
                    {
                        c1 :: int, p_tot :: end_p_tot :: ef :: double
                        
                        code
                        
                        ef = args[1]
                        iterate(0, code, end_factor = ef, f_or_w = w)
                        
                        p_tot = end_p_tot = 0
                        for c1 in <1, numLoci>  (
                            p_tot = that + sumLocusProbs[c1]
                            if c1 <= iterate.n_skip_max+1 xor c1 >= numLoci-iterate.n_skip_max  then (
                                end_p_tot = that + sumLocusProbs[c1]
                        )   )
                        
                        if numLoci >= 2*(iterate.n_skip_max+1)  then &
                            return p_tot/numLoci - end_p_tot/iterate.n_skip_max/2
                        else  &
                            return end_p_tot/(2*(iterate.n_skip_max+1) - 2*numLoci) - p_tot/numLoci
                    }
                    
                   code
                   
                   search_step = params.search_w_step
                   tol = params.set_w_tol
                   min = -1000, max = 1000
            )   )
            
            else  ( *|
                
                for loopSpot in <1, numSpots>  &
                    overlapField[loopSpot] = -overlapField[numSpots+1]

                overlapField[numSpots+1] = 0
                
        ))  | )
        
        done_restart = true
    }
    
    
    iterate :: {
        
        params :: {
            step_size :: line_min_param :: max_convergence :: exaggeration :: double
            f_or_w :: opt_method :: int
            calcExact :: bool
            this.f := 1, this.w := 2              }
        params.exaggeration = @exaggeration
        C_history :: [*][2] double
        calc_count :: calc_time :: FE :: logZ :: fn_cost :: double
        max_iterations :: iters :: cum_iters :: iter_counter :: n_skip_max :: cd :: int
        iter_list :: { iters, (none::int) = 0 }
        restart.params.fn_cost := @fn_cost
        
        if_log :: bool
        
        
        code
        
        if not done_restart  then (
            printl("Can't run iterate() before loading a chain")
            return      )
        
        params.f_or_w = params.f
        params.calcExact = false
        if trap( ;
            { max_iterations } = args
            (params << args)()
        ) /= passed  then (
            printl("usage: aligner3d.iterate(max_iterations ; params from { opt_method, step_size, line_min_param, max_convergence } = values)")
            return      )
        
        calc_count = calc_time = 0
        iters = max_iterations
        C_history[^iters+1]
        
        if if_log  then (
            trap(remove Log)
            Log :: [iters+1] [size(restart.params.Log)/size(double)] double
            Log[1] =! restart.params.Log        )
        
|        for iter_counter in <1, 2>  (
 |           if iters == 0  then iter_counter = 2
            call("IterateProbs", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz, sumSpotProbs,
                            overlapField, gradOverlapField, colorRange, loci, mask, p, Z_1x, Z_xN, Z_1x_norm, Z_xN_norm, Z, dC_dZ,
                            sensitivity, sensitivity_norm, sumLocusProbs, neighbors, l_step, lp, n_skip_max,
                            p_fn, exaggeration, fn_cost, params.step_size, params.line_min_param, C_history, restart.params.Log, Log,
|                            calc_count, calc_time, FE, iter_list[iter_counter], params.max_convergence, params.opt_method, params.f_or_w,
                            calc_count, calc_time, FE, iter_list[1], params.max_convergence, params.opt_method, params.f_or_w,
                            params.calcExact, 0.) |pLR)
  |          if params.calcExact  then iter_counter = 2     )
        
        cum_iters = that + iters
        
        logZ = 0
        for cd in <1, numLoci>  &
            logZ = that + log(Z[cd]) + Z_1x_norm[cd] + Z_xN_norm[cd]

        logZ = that / numLoci
        for cd in <1, numSpots>  &
            logZ = that + sumSpotProbs[cd]*overlapField[cd]

        logZ = that + p_fn*overlapField[numSpots+1]
        
        if if_log  then (
            Log[^iters+1]                       | in case iters < max_iterations
            saveTable(fullPath("ConvLog.txt"), Log)     )
        
        C_history[^iters+1]
        saveTable(fullPath("Cs.txt"), C_history)
        
        return new({ iters, C_history[iters+1], calc_count, calc_time, logZ })
    }
    
    
        | fix() and free() allow the user to dial in certain parts of a mapping while letting the align3d engine estimate the rest of the mapping probabilistically
    
	maskProbsTemplate :: {

        min :: max :: c1 :: int
		
		code
		
		if trap(
			if trap( min = args[1] ) /= passed  then (
                { min, max } = args[1]
                if max < 1 or max > numLoci  then throw(1)  )
            else  max = min

			if min < 1 or min > numLoci  then throw(1)
            
			if top(args) > args_top  then throw(1)
		) /= passed  then (  printl(usage_message), return  )
		
		for c1 in <min, max> &
            mask[c1] = mask_value
	}
    
    
    fix :: maskProbsTemplate : {
        args_top := 2
        usage_message := "usage: aligner3d.fix(locus # / { min spot #, max spot # } <= numLoci [, spot_num (0 for max)])"
        mask_value := 0
        
        spot_num :: spots_top :: c2 :: best_spot :: int
        spots :: [] double, max_spot_prob :: double
        
        code
        
        if top(args) == 2  then (
            if trap(spot_num = args[2]) /= passed  then (
                printl(usage_message, "  (warning -- mask has been changed)")
                return      )

            for c1 in <min, max>  (
                spots[*] =! p[c1]
                spots_top = top(spots)
                
                if spot_num <= spots_top  then (
                    if spot_num == 0  then (
                        max_spot_prob = 0, best_spot = 1
                        for c2 in <1, spots_top>  (
                        if spots[c2] > max_spot_prob  then (
                            max_spot_prob = spots[c2], best_spot = c2
                        ))
|*                        best_spot = max(spots; rtrn = index)*|       )

                    else  best_spot = spot_num

                    for c2 in <1, spots_top>  (
                        if c2  == best_spot  then spots[c2] = 1
                        else  spots[c2] = 0     )

                    p[c1] =! spots      )

                else  printl("fix() warning: spot_num > numSpots for locus # = ", c1)
        )   )
    }
    
    free :: maskProbsTemplate : {
        args_top := 1
        usage_message := "usage: aligner3d.free(min / { min, max } <= numLoci)"
        mask_value := 1
    }
    
    
    
    printProbs :: {
        
        probs :: [] double
        c1 :: the_color :: p0 :: pf :: int
        params :: { list :: group :: int, pZ := 0, s := 2 }
        the_list :: exp_list :: *
        if_exp :: bool
        exp_string :: string
        
        code
        
        if trap(
            if top(args) == 0  then (  p0 = 1, pf = numLoci  )
            else if top(args) == 1  then p0 = pf = args[1]
            else if top(args) == 2  then (  p0 = args[1], pf = args[2]  )
            else  throw(1)

            if p0 < 1 or pf < 1 or p0 > numLoci or pf > numLoci  then throw(2)
            
            params.list = 0, params.group = params.pZ
            (params<<args)()
            
            if_exp = false
            
            if params.group == params.pZ  then (
                if params.list == -1  then (  the_list = @Z_1x, exp_list = @Z_1x_norm, if_exp = true  )
                else if params.list == 0  then the_list = @p
                else if params.list == 1  then (  the_list = @Z_xN, exp_list = @Z_xN_norm, if_exp = true  )
                else  throw(1)      )
            else if params.group == params.s  then (  the_list = @sensitivity, exp_list = @sensitivity_norm, if_exp = true  )
            else  throw(1)
        ) /= passed  then (
            print("usage:  aligner3d.printProbs([lower bound [, upper bound]] [; list = { -1 (Z_1x) or 0 (probs) ")
            printl("or +1 (Z_xN)}, group = pZ/s/f/grad_f])")
            return      )
        
        for c1 in <p0, pf>  (
            probs[*] =! the_list[c1]
            the_color = loci[c1].color + 1
            
            print(c1, " (", colorRange[the_color].low, " -- ", colorRange[the_color].high, "):  ")
            if not if_exp  then sprint(probs)
            else  (
                print_string(exp_string, "x 10^", exp_list[c1]/log(10), " (", exp_list[c1], ")")
                sprint(probs, exp_string)
        )   )
        
        the_list = @nothing, exp_list = @nothing
    }
    
    
    exportProbs :: {
        
        all_probs :: [] { l :: x :: y :: z :: prob :: double, color :: int }
        probs :: [] double
        one_color_range :: { low :: high :: int }
        c1 :: c2 :: one_color :: int
        fileStr :: string


        code
        
        if trap(fileStr = args[1]) /= passed  then &
            fileStr = fullPath("AllProbs.txt")

        all_probs[^size(p)/size(double)]
        
        ap_top := 0
        
        for c1 in <1, numLoci>  (
            
            probs[*] =! p[c1]
            one_color = loci[c1].color + 1
            one_color_range = colorRange[one_color]
            
            for c2 in <one_color_range.low, one_color_range.high>  (
                ap_top = that + 1
                all_probs[ap_top] = { loci[c1].l, spots[c2].x, spots[c2].y, spots[c2].z,
                                    probs[c2 - one_color_range.low + 1], one_color }
        )   )
        
        saveTable(fileStr, all_probs)
    }
    
    
        | a silly routine to try to guess the best mapping
        | (doesn't take into account the no-overlap condition)
    
    bestMap :: {
        
        idx :: best_spot :: int
        probs :: [] double


        code
        
        if trap( { idx } = args ) /= passed  then (
            printl("usage:  image_spot = aligner3d.bestMap(index)")
            return      )
        else if idx < 1 or idx > numLoci   then &
            printl("bestMap() error:  index out of range")
        else if not done_restart  then &
            printl("bestMap() error:  haven't yet initialized p-values")

        probs[*] =! p[idx]
        best_spot = max(probs; rtrn = index) + colorRange[loci[idx].color+1].low - 1
        if max(probs) < 1. - sumLocusProbs[idx]  then best_spot = 0

        return new(best_spot)
    }
    
    
    occupancy :: {
        tot_prob :: double
        c1 :: the_color :: p0 :: pf :: int
        
        code
        
        if trap(
            if top(args) == 0  then (  p0 = 1, pf = numLoci  )
            else if top(args) == 1  then p0 = pf = args[1]
            else if top(args) == 2  then (  p0 = args[1], pf = args[2]  )
            else  throw(1)

            if p0 < 1 or pf < 1 or p0 > numLoci or pf > numLoci  then throw(2)
        ) /= passed  then (  printl("usage:  aligner3d.occupancy([lower bound [, upper bound]])"), return  )
        
        tot_prob = 0
        for c1 in <p0, pf>  &
            tot_prob = that + sumLocusProbs[c1]

        return new(tot_prob / (pf - p0 + 1))
    }
    
    
        | outputs a table of spot-to-spot 'distances' (free energies) suitable for a traveling-salesman solver
        | (this requires that the spots be equally spaced)
    
    saveTSP :: {
        
        c1 :: c2 :: int
        L :: GP :: double
        
        code
        
        if top(args) /= 0  then (  printl("usage: saveTSP()"), return 1  )
        if p_fn /= 0 or p_fp /= 0 or numLoci /= numSpots  then (
            printl("saveTSP():  p_fn and p_fp must equal 0")
            return 2            )

        if numLoci > 1  then (
            L = loci[2].l - loci[1].l
            for c1 in <2, numLoci-1>  (
            if loci[c1+1].l - loci[c1].l /= L  then (
                printl("saveTSP() error:  locus spacing is not equal")
                return 3
        )   ))
        
        TSP_table :: [numSpots] [numSpots] double
        
        for c1 in <1, numSpots>  (
            TSP_table[c1][c1] = 0
            for c2 in <1, c1-1>  (
                call("GaussianChain", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz, L, lp, c1, c2, GP)
                TSP_table[c1][c2] = TSP_table[c2][c1] = GP
        )   )
        
        saveTable(fullPath("TSP_table.txt"), TSP_table)
        
        remove TSP_table
    }
    
    
    entropyTemplate :: {
        
        result :: one_p :: double
        ps :: [] double
        order :: [*] int
        c1 :: c2 :: one_top :: l_bound :: u_bound :: int
        params :: {
            
            x_res :: y_res :: z_res :: double
            countFalseNegatives :: bool
        
            set_res :: {
                
                code
                
                if trap( { x_res } = args ) /= passed  then (
                    printl("usage: set_res(resolution)")
                    return      )

                y_res = z_res = x_res   }         }
        
        param_pass :: { params.x_res, params.y_res, params.z_res, params.countFalseNegatives }
        
        base := 2
        
        
        code
        
        if trap(
            if top(args) == 0  then (  l_bound = 1, u_bound = numLoci  )
            else if top(args) == 1  then l_bound = u_bound = args[1]
            else if top(args) == 2  then (  l_bound = args[1], u_bound = args[2]  )
            else  throw(1)
            
            param_pass = { 0, 0, 0, true }
            (params << args)()
        ) /= passed  then (
            printl("usage:  result = aligner3d.", name, "( [ l_bound [, u_bound ] ] ; x_res/y_res/z_res/countFalseNegatives = values or set_res(resolution))")
            return      )

        get_order()
        
        call("Entropy", spots[*].x, spots[*].y, spots[*].z, p[<l_bound, u_bound>],
                loci[<l_bound, u_bound>].color, colorRange, order, param_pass, result)
        
        return new(result/log(base)/numLoci)
    }
    
    
    entropy :: entropyTemplate : { name := "entropy", order[^0], get_order :: {} }
    
	
    this(0, 0, 0)
    
    
    
    code
    
    if trap(
        if top(args) /= 3  then throw(1)
        
        (numLoci :: int) = args[1]
        (numSpots :: int) = args[2]
        (numColors :: int) = args[3]
    ) /= passed  then (  printl("usage:  aligner3d(numLoci, numSpots, numColors)"), return  )
    
    spots[^numSpots]
    loci[^numLoci]
    
    colorRange[^numColors]
    
    p[^numLoci]
    Z_1x[^numLoci]
    Z_xN[^numLoci]
    sensitivity[^numLoci]
    overlapField[^numSpots+1]
    gradOverlapField[^numSpots+1]
    Z_1x_norm[^numLoci]
    Z_xN_norm[^numLoci]
    Z[^numLoci]
    dC_dZ[^numLoci]
    sensitivity_norm[^numLoci]
    
    sumLocusProbs[^numLoci]
    mask[^numLoci]
    
    sumSpotProbs[^numSpots]
	
    if numLoci > 0  then mask[<1, numLoci>] = 1

    
    
    code
    
    sort(spots, 7)
    
    current_color = 0
    colorRange[1].low = 1
    for cs in <1, numSpots>  (
        if spots[cs].color /= current_color  then (
            colorRange[current_color+1].high = cs-1
            current_color = that + 1
            colorRange[current_color+1].low = cs
            cs = that - 1
    )   )
    colorRange[current_color+1].high = numSpots
    for current_color in <current_color+2, numColors>  &
        colorRange[current_color] = { numSpots+1, numSpots }
}






| ************************************** MonteCarloSim class **************************************
| 
| MonteCarloSim couples the aligner3d class to the Monte Carlo component, allowing the user to work with simulated conformations.
| 
| typical usage:
| 
| MonteCarloSim.getChain(1000; init_num(3, 5), mode = "random_chain")    | 1 kb DNA segment with 8 spots (3 of one color, 5 of the other)
| MonteCarloSim.restart()                                                | begins a reconstruction
| MonteCarloSim.iterate(100)                                             | iterates the align3d algorithm to (hopefully) a solution



MonteCarloSim :: MC : {
    
    simSpots :: [*] (aligner3d.spots [*] : { this.bp :: int, this.l :: double })
    C2F :: F2C :: [] int
    NoMSE :: [*][3] double
    total_bp :: int
    doing_2D := false
    doing_twist := true
    
    initWormlike(code, persistence_length = 50/.3, segment_length = 1)
    initWormlike(code, persistence_length = 50/.3, segment_length = 1)
    
    getChain :: {
        loopSpot :: chain_its :: new_color :: loop_color :: indices_to_subtract :: c1 :: int
        extra_indices :: [] int
        R2 :: max_R2 :: max_xyz :: new_x :: new_y :: new_z :: double
        minmax_xyz :: [3][2] double
        FNDots :: [] spot
        last_mode :: string
        chain_it_pdz_leeway := 1.01             | to prevent it from getting stuck
        
        l_tot :: l_plec :: back_plec_top :: one_subunit :: int             | "genome" mode params
        totalChain :: segments

        params :: {
            p_false_positive :: p_false_negative :: fp_padding :: backbone_frac :: lp :: double
            mode :: string
            chromosome_length :: chromosome_width :: plectoneme_dz :: double
            do_2D := false
            
            lp = 50/.3
            p_false_positive = p_false_negative = 0
            fp_padding = 200
            backbone_frac = 0.5
            mode = "random_chain"
            chromosome_length = 2000/l_bp/2^(1/3)
            chromosome_width = 1000/l_bp/2^(1/3)
            plectoneme_dz = chromosome_width/5            }
        
        params.init_template :: {
            
            loop_color :: topSpot :: to_add :: int
            
            params :: {
                xy_err :: xy_err_increase :: double
                z_err :: z_err_increase :: double            }
            
            adjust_errors :: {
                loopSpot :: int, z_dev :: double
                
                code
                
                for loopSpot in <1, numSpots>  (
                    z_dev = abs(spots[loopSpot].z)
                    spots[loopSpot].dx = that + params.xy_err_increase * z_dev
                    spots[loopSpot].dy = that + params.xy_err_increase * z_dev
                    spots[loopSpot].dz = that + params.z_err_increase * z_dev       )
            }
            
            code
            
            (params<<{  code
                xy_err = 8/l_bp  |1/(2*(20/.3)^2)
                xy_err_increase = 2/15
                z_err = 22/l_bp    |1/(2*(40/.3)^2)
                z_err_increase = 1/15  })()
            (getChain.params << { code, p_false_positive = p_false_negative = 0  })()
            
            topSpot = 0
            simSpots[^0]
            
            numColors = top(args)
            for loop_color in <1, numColors>  (
                
                if trap(
                    if args[loop_color] < 0  then throw(1)
                    to_add = args[loop_color]
                    (params<<args)()
                ) /= passed  then (
                    printl("usage: ", name_string, "(# spots for 1st color >= 0, # spots 2nd color, ...[ ; xy_err/z_err = values])")
                    throw(1)        )

                simSpots[^topSpot + to_add]
                for loopSpot in <topSpot + 1, topSpot + to_add>  (
                    simSpots[loopSpot].color = loop_color-1
                    simSpots[loopSpot].dx = simSpots[loopSpot].dy = params.xy_err
                    simSpots[loopSpot].dz = params.z_err        )

                topSpot = that + to_add     )

            for loopSpot in <1, topSpot>  (
                simSpots[loopSpot].bp = bp_fn(loopSpot, topSpot)
                simSpots[loopSpot].l = simSpots[loopSpot].bp * initWormlike.params.segment_length   )

            getChain.adjust_errors := @adjust_errors                        }
        
        
        params.init_predefined :: params.init_template : {
            
            name_string := "init_predefined"
            
            bp_fn :: {  code, return params.spot_positions[args[1]]  }               }
        
        
        params.init_num :: params.init_template : {
            
            name_string := "init_num"
            
            bp_fn :: {  code, return ceil(random()*total_bp)  }               }
        
        
        params.init_regular :: params.init_template : {
            
            name_string := "init_regular"
            
            bp_fn :: {
                
                position :: int
                
                code
                
                position = floor(total_bp / args[2]) * args[1]
                
                return position         }                   }
        
        
        code
        
        trap(remove adjust_errors)
        
        last_mode = params.mode
        if trap( ;
            if top(args) /= 1  then throw(1)
            total_bp = args[1]
            (params << args)()
        ) /= passed  then (
            printl("usage: TF.getChain(N_segments ; { init_num()/init_regular() } [, p_false_negative/p_false_positive/"
                   "plectoneme_dz/chromosome_length/chromosome_width] = value, mode = \"random_chain\"/\"genome\"/\"keep_old_chain\"])")
            return      )

        if params.do_2D /= doing_2D  then (
            doing_2D = params.do_2D
            if doing_2D  then doing_twist = false
            else  doing_twist = true
            initWormlike(code, persistence_length = params.lp, segment_length = 1, init_2D = doing_2D, do_twist = doing_twist)      )

        sort(simSpots, 8)
        
        numLoci = numSpots = top(simSpots)
        false_pos_num := numSpots*(1-params.p_false_negative)*params.p_false_positive/(1-params.p_false_positive)
        
        loci[^numLoci]
        spots[^numSpots]
        C2F[^numLoci]
        F2C[^numSpots]
        
        spots[*].color = simSpots[*].color
        { spots[*].dx, spots[*].dy, spots[*].dz } = { simSpots[*].dx, simSpots[*].dy, simSpots[*].dz }
        loci[*].color = simSpots[*].color
        loci[*].l = simSpots[*].l
        
        
            | generate the contour, if we need to
        
        if params.mode == "keep_old_chain"  then (
            
            params.mode = last_mode
            if (params.mode == "random_chain" and total_bp+1 /= top(segments)) or (params.mode == "genome" and total_bp+1 /= top(totalChain))  then (
                printl("getChain() error:  L must stay the same in keep-old-chain mode")
                return
        )   )
        
        else if params.mode == "random_chain"  then (
            
            density(NumberOfSegments :: [] int, NumberOfSegments[*] = simSpots[*].bp, NumberOfSegments[+numSpots+1] = total_bp, 1;
                    if doing_2D  then { u0, n0, b0 } = { { 0, 1, 0 }, { 1, 0, 0 }, { 0, 0, -1 } }  )
            
            for loopSpot in <1, numSpots>  &
                { spots[loopSpot].x, spots[loopSpot].y, spots[loopSpot].z } = sampled_rs[1][loopSpot]
            
            totalChain[*] = segments[*]     )
        
        else if params.mode == "genome"  then (
            
            totalChain[^total_bp+1]
            
            l_tot = 1
            totalChain[1] = {{ 0, 0, 0 }, { 1, 0, 0 }, { 0, 0, -1 }, { 0, 1, 0 }}

            while l_tot < total_bp  do (
                
                l_plec = ceil(random()*params.chromosome_width)
                if l_plec + l_tot > total_bp + 1 then &
                    l_plec = total_bp - l_tot + 1
                
                chain_its = 0
                loop
                    last_segment := totalChain[l_tot]
                    density(l_plec, 1; { r0, n0, b0, u0 } = last_segment)
                    chain_its = that+1
                until abs(segments[l_plec+1].r[1] - params.chromosome_length * (l_tot / total_bp)) < params.plectoneme_dz * chain_it_pdz_leeway^chain_its  &
                            and  segments[l_plec+1].r[2]^2 + segments[l_plec+1].r[3]^2 < (params.chromosome_width/2)^2 * chain_it_pdz_leeway^chain_its
                
                totalChain[<l_tot, l_tot+l_plec>] = segments[*]            | will re-write the boundary elements
                l_tot = that + l_plec
                
                back_plec_top = ceil(random()^(2*params.backbone_frac/(1-params.backbone_frac)) * l_plec)
                if back_plec_top + l_tot > total_bp + 1  then &
                    back_plec_top = total_bp - l_tot + 1

                for c1 in <1, back_plec_top>  &
                    totalChain[l_tot + c1] = totalChain[l_tot - c1]

                l_tot = that + back_plec_top        )

            for loopSpot in <1, numSpots>  (
                one_subunit = simSpots[loopSpot].bp + 1
                { spots[loopSpot].x, spots[loopSpot].y, spots[loopSpot].z } = totalChain[one_subunit][1]
        )   )

        else  (
            printl("getChain() error:  mode must be one of \"random_chain\"/\"genome\"/\"keep_old_chain\"")
            params.mode = "keep_old_chain"
            return      )
        
        saveTable(fullPath("RealChain.txt"), totalChain[*].r)
        
        max_R2 = 0
        for loopSpot in <1, numSpots>  (
            R2 = spots[loopSpot].x^2 + spots[loopSpot].y^2 + spots[loopSpot].z^2
            if R2 > max_R2  then max_R2 = R2        )
        max_xyz = (max_R2/3)^.5         | heuristic
        
        { minmax_xyz[1][1], minmax_xyz[1][2] } = { min(spots[*].x), max(spots[*].x) }
        { minmax_xyz[2][1], minmax_xyz[2][2] } = { min(spots[*].y), max(spots[*].y) }
        { minmax_xyz[3][1], minmax_xyz[3][2] } = { min(spots[*].z), max(spots[*].z) }
        for c1 in <1, 3>  (
            minmax_xyz[c1][1] = that - params.fp_padding
            minmax_xyz[c1][2] = (that + params.fp_padding) - minmax_xyz[c1][1]      )

        for c1 in <1, numLoci>  &
            C2F[c1] = F2C[c1] = c1

        sort(F2C, spots[*].color)
        sort(C2F, F2C)
        sort(spots, 7)
        
        indices_to_subtract = 0
        
        
            | remove the false negatives
        
        FNDots[^0]
        for loopSpot in <1, numSpots>  (
            if random() < params.p_false_negative  then (
                FNDots[+top(FNDots)+1] = spots[loopSpot]
                
                C2F[F2C[loopSpot]] = 0
                remove F2C[loopSpot]
                remove spots[loopSpot]
                
                loopSpot = that - 1
                numSpots = that - 1
                indices_to_subtract = that + 1      )
            else  (
                C2F[F2C[loopSpot]] = that - indices_to_subtract
        )   )
        
        
            | add the false positives
        
        extra_indices[^0], extra_indices[^numColors]
        
        for loopSpot in <1, false_pos_num>  (
            
            if params.mode == "random_chain" or params.mode == "genome"  then (
                { new_x, new_y, new_z, new_color } = {
                    minmax_xyz[1][2]*random() + minmax_xyz[1][1]
                    minmax_xyz[2][2]*random() + minmax_xyz[2][1]
                    minmax_xyz[3][2]*random() + minmax_xyz[3][1]
                    spots[ceil(random()*numSpots)].color }
            
|*            else if params.mode == "genome"  then (
                loop
                    { new_x, new_y, new_z, new_color } = { random()*params.chromosome_length, (2*random() - 1)*params.chromosome_width,
                                                (2*random() - 1)*params.chromosome_width, spots[ceil(random()*numSpots)].color }
                until new_y^2 + new_z^2 <= (params.chromosome_width/2)^2
*|            )
            
            for loop_color in <new_color+2, numColors>  &
                extra_indices[loop_color] = that + 1
            
            numSpots = that + 1
            (spots[+numSpots] << {
                code
                color = new_color
                x = new_x, y = new_y, z = new_z
                dx = spots[1].dx, dy = spots[1].dy, dz = spots[1].dz
            })()
            F2C[+numSpots] = 0
        )

        sort(F2C, spots[*].color)
        sort(spots, 7)
        
        for loopSpot in <1, numLoci>  (
        if C2F[loopSpot] /= 0  then (
            C2F[loopSpot] = that + extra_indices[loci[loopSpot].color+1]
        ))
        
        
            | factor in microscope error
        
        trap(adjust_errors())     | adjust each spot's xyz error for being out of the focal plane
        
        NoMSE[^numSpots]
        
        for c1 in <1, numSpots>  (
            spots[c1].x = that + grand(spots[c1].dx)
            spots[c1].y = that + grand(spots[c1].dy)
            spots[c1].z = that + grand(spots[c1].dz)
            
            if F2C[c1] > 0  then &
                NoMSE[c1] = totalChain[simSpots[F2C[c1]].bp].r
            else &
                NoMSE[c1] = { spots[c1].x, spots[c1].y, spots[c1].z }
        )
        
        saveTable(fullPath("Labels.txt"), loci)
        saveTable(fullPath("Dots.txt"), spots)             | for visualizing in MATLAB
        saveTable(fullPath("FNDots.txt"), FNDots)
        saveTable(fullPath("F2C.txt"), F2C)
        saveTable(fullPath("NoMSE.txt"), NoMSE)
    }
}







| ************************************** aligner3dSim class **************************************
| 
| aligner3dSim modifies the MonteCarloSim class for purposes of testing the align3d algorithm
| 
| typical usage:
| 
| aligner3dSim.getChain(1000; init_num(3, 5), mode = "random_chain")    | 1 kb DNA segment with 8 spots (3 of one color, 5 of the other)
| aligner3dSim.restart()                                                | begins a reconstruction
| aligner3dSim.iterate(100)                                             | iterates the align3d algorithm to (hopefully) a solution


aligner3dSim :: aligner3d : MonteCarloSim : {
    
    getChain :: getChain : {
        
        code
        
        trap(remove iterate.params.Log)
        parent(numLoci, numSpots, numColors)
        parent#2()
        
        chain_loaded = true
        done_restart = false
    }
    
    
    neighborReport :: {
        
        nbs :: [] int
        min_sep :: max_sep :: true_nbs_counted :: total_true_nbs :: total_nbs :: int
        total_spots :: c1 :: c2 :: c3 :: nb_base :: which_l_index :: nbtop :: int
        
        code
        
        if trap(
            if top(args) == 0  then &
                min_sep = max_sep = 1
            else if top(args) == 1  then &
                min_sep = max_sep = args[1]
            else if top(args) == 2  then (
                min_sep = args[1]
                max_sep = args[2]   )
            else  &
                throw(1)
        ) /= passed  then printl("usage:  { true_neighbor_fraction, calc_reduction_factor } = TF.neighborReport([min sep [, max sep]])")
        
        true_nbs_counted = total_true_nbs = total_nbs = total_spots = 0
        
        for c1 in <min_sep, max_sep>  (
        for c2 in <1, numLoci - c1>  (          | don't also have to count 'b' as a neighbor of 'a' -- that's redundant
            if C2F[c2] >= 1 and C2F[c2+c1] >= 1  then (
                which_l_index = ceil((loci[c2+c1].l - loci[c2].l)/l_step)
                if which_l_index <= l_num  then (
                    nb_base = ( (C2F[c2]-1)*numColors + loci[c2+c1].color )*l_num + 1
                    nbs[*] =! neighbors[<nb_base, nb_base + which_l_index - 1>]
                    nbtop = top(nbs)
                    
                    for c3 in <1, nbtop>  (
                    if nbs[c3] + 1 == C2F[c2+c1]  then (          | + 1 to account for the fact that neighbors are stored starting from ID 0
                        true_nbs_counted = that + 1
                        c3 = nbtop
                    ))
                    total_nbs = that + nbtop        )
                
                else    (
                    true_nbs_counted = that + 1
                    total_nbs = that + numSpots-1     )

                total_true_nbs = that + 1
                total_spots = that + numSpots-1
        ))  )
        
        return new({ true_nbs_counted/total_true_nbs, total_spots/total_nbs })
    }
    
    
    bestGuess :: {
        Guess :: [] int
        GuessPos :: [] { x :: y :: z :: double }
        probs :: [] double
        best_prob :: double
        c1 :: c2 :: the_color :: spots_num :: score :: int
        
        code
        
        if top(args) /= 0  then (  printl("usage:  score = TF.bestGuess()"), return  )
        
        Guess[^numLoci]
        GuessPos[^numLoci]
        
        score = 0
        for c1 in <1, numLoci>  (
            probs[*] =! p[c1]
            spots_num = top(probs)
            
            if spots_num > 0  then (
                
                the_color = loci[c1].color + 1
                
                best_prob = -1
                for c2 in <1, spots_num>  (
                if probs[c2] > best_prob  then (
                    best_prob = probs[c2]
                    Guess[c1] = c2 + colorRange[the_color].low - 1
                ))
                
                if best_prob > 1 - sumLocusProbs[c1]  then (
                    { GuessPos[c1].x, GuessPos[c1].y, GuessPos[c1].z } = { spots[Guess[c1]].x, spots[Guess[c1]].y, spots[Guess[c1]].z }
                    if F2C[Guess[c1]] == c1  then score = that+1            )
                else  (
                    { Guess[c1], GuessPos[c1].x, GuessPos[c1].y, GuessPos[c1].z } = { 0, 0, 0, 0 }
                    if C2F[c1] == 0  then score = that+1
            )   )

            else  (
                { Guess[c1], GuessPos[c1].x, GuessPos[c1].y, GuessPos[c1].z } = { 0, 0, 0, 0 }
                score = that + 1
        )   )
        
        saveTable(fullPath("GuessChain.txt"), GuessPos)
        
        return new(score/numLoci)
    }
    
    
    missingInfo :: {

        probs :: [*] double
        info :: base :: prob_sum :: double
        c1 :: c2 :: the_color :: spots_num :: int
        base = 2


        code
        
        if top(args) /= 0  then (  printl("usage:  info = TF.missingInfo()"), return  )
        
        info = 0
        for c1 in <1, numLoci>  (
            probs[*] =! p[c1]
            spots_num = top(probs)
            the_color = loci[c1].color + 1
            
            if C2F[c1] >= 1  then &
                info = that - log(probs[C2F[c1] - colorRange[the_color].low + 1])
            else  (
                prob_sum = 0
                for c2 in <1, spots_num>  &
                    prob_sum = that + probs[c2]
                if prob_sum >= 0 and prob_sum < 1  then (
                    info = that - log(1-prob_sum)
        )   )   )
        
        return new(info/log(base)/numLoci)
    }
    
    
        | counts the number of ps and 'hits' for each bin of p-values
        | call "binProbs(# bins)" after first run to initialize; then just "binProbs()" after each subsequent run to add to bins
    
    binProbs :: {
        probs :: [] double
        bins_num :: c1 :: c2 :: spots_num :: the_color :: the_bin :: int
        params :: { if_bin :: bool }
        if_reset :: if_save :: bool
        Bins :: [0] { Total :: Correct :: int }


        code
        
        if_save = true
        trap(remove params.Bins)
        
        if trap(
            
            if top(args) == 0  then if_reset = false
            else if top(args) == 1  then (  if_reset = true, bins_num = args[1]  )
            else  throw(1)

            params.if_bin = true
            (params<<args)()
            
        ) /= passed  then (  printl("usage:  TF.binProbs([, # of bins if resetting] [ ; Bins := @my_array, if_bin = true/false])"), return  )
        
        if trap(params.Bins) == passed  then &
            if_save = false
        else  &
            params.Bins := @Bins

        if if_reset  then (
            trap(params.Bins[^0], params.Bins[^bins_num])
            for c1 in <1, bins_num>  (
                params.Bins[c1] = { 0, 0 }
        )   )
        else  bins_num = top(params.Bins)

        if not params.if_bin  then return
        
        for c1 in <1, numLoci>  (
            probs[*] =! p[c1]
            spots_num = top(probs)
            the_color = loci[c1].color + 1
            
            for c2 in <1, spots_num>  (
                the_bin = ceil(probs[c2]*bins_num)
                if the_bin == 0  then the_bin = 1
                if the_bin <= bins_num  then (          | i.e. if the prob <= 1
                    params.Bins[the_bin][1] = that + 1
                    if F2C[c2 + colorRange[the_color].low - 1] == c1  then params.Bins[the_bin][2] = that+1
        )   )   )
        
        if if_save  then &
            saveTable(fullPath("BinnedProbs.txt"), params.Bins)
        else  &
            remove params.Bins
    }
    
    
    info :: entropyTemplate : {
        name_and_args := "info"
        get_order :: { ; order[*] = C2F[<l_bound, u_bound>] }                }
    
    
    exportProbs :: exportProbs : {
        
        true_probs :: [*] all_probs[*]


        code
        
        true_probs[^numLoci]
        
        tp_top := 0
        
        for c1 in <1, numLoci>  (
            
            probs[*] =! p[c1]
            one_color = loci[c1].color + 1
            one_color_range = colorRange[one_color]
            
            if C2F[c1] /= 0  then (
                tp_top = that + 1
                true_probs[tp_top] = { loci[c1].l, spots[C2F[c1]].x, spots[C2F[c1]].y, spots[C2F[c1]].z,
                                    probs[C2F[c1] - one_color_range.low + 1], one_color }
        )   )

        true_probs[^tp_top]         | deal w/ false negatives
        
        saveTable(fullPath("TrueProbs.txt"), true_probs)
    }
}




| 1D root finder for sign(f) = sign(x-x0)

optimize_1D :: {
    
    low :: high :: mid :: to_push :: other :: double
    params :: {  search_step :: tol :: min :: max :: double  }
    
    
    code
    
    if trap(
        if top(args) /= 1  then throw(1)
        params = { 1, 1e-4, -1e4, 1e4 }
        (params<<args)()
    ) /= passed  then (
        printl("usage:  optimize_1D(f (returns > 0 (too high) or < 0 (too low)) [ ; params from search_step/tol/min/max = values])")
        return      )
    
    
        | first bracket the root
    
    low = high = 0
    tol := params.tol
    push_distance :: double
    
    if args[1](low) < 0  then &
        to_push = @high, other = @low, push_distance = 1
    else &
        to_push = @low, other = @high, push_distance = -1

    loop
        other = to_push
        to_push = that + push_distance * params.search_step
        push_distance = that * 2
    until push_distance * args[1](to_push) >= 0 or push_distance < params.min or push_distance > params.max
    
    
        | iterate the root finder
    
    loop
        mid = (low + high) / 2
        
        if args[1](mid) < 0  then low = mid
        else  high = mid
    until high - low < params.tol
    
    return (low + high)/2
}


| grand() calculates a random number from a Gaussian distribution

grand :: {
    
    result :: sigma :: double
    
    code
    
    if trap( {sigma} = args ) /= passed  then (
        printl("usage:  rnd = grand(sigma)")
        return *        )

    call("GaussRand", sigma, result)
    
    return new(result)
}

call("InitGaussRand")
