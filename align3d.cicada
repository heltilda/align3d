l_bp := 0.3         | base pair length in nm

path := "~/align3d/Results/"
fullPath :: { fp :: string; print_string(fp, path, args), return new(fp) }


locus :: {
    l :: double
    color :: int      }

spot :: {
    x :: y :: z :: dx :: dy :: dz :: double
    color :: int          }




| ************************************** aligner3d class **************************************
| 
| aligner3d is used to perform conformational reconstructions using a set of loci along with a spot 'image' (set of 3D positions and colors).
| 
| typical usage:
| 
| aligner3d.loadExperiment("myloci.txt", "myimage.txt")     | load the data files
| aligner3d.restart()                                       | begin a reconstruction
| aligner3d.iterate(100)                                    | iterate the align3d algorithm to (hopefully) a converged solution


aligner3d :: {
    
    loci :: [] locus
    spots :: [] spot
    
    colorRange :: [] { low :: high :: int }
    
    p :: Z_1x :: Z_xN :: sensitivity :: neighbors :: [] string
    overlapField :: gradOverlapField :: Z_1x_norm :: Z_xN_norm :: Z :: dC_dZ :: sensitivity_norm :: sumLocusProbs :: sumSpotProbs :: [] double
    mask :: [] int
    
    lp :: p_fn :: p_fp :: exaggeration :: l_step :: double
    current_color :: l_num :: cs :: int
    
    chain_loaded := done_restart := false
    
    
    loadExperiment :: {
        
        lociFileName :: imageFileName :: lociFileString :: imageFileString :: string
        
        code
        
        if trap( { lociFileName, imageFileName } = args ) /= passed  then (
            printl("usage:  loadExperiment(loci file, spots file)")
            return      )
        
        if trap(lociFileString = Load(lociFileName)) /= passed  then (
            printl("aligner3d.loadExperiment() error:  file ", lociFileName, " could not be found or opened")
            return      )
        if trap(imageFileString = Load(imageFileName)) /= passed  then (
            printl("aligner3d.loadExperiment() error:  file ", imageFileName, " could not be found or opened")
            return      )
        
        readTable(loci, lociFileString)
        if readTable.errCode /= passed  then (
            printl("aligner3d.loadExperiment() error reading loci file")
            parent(0, 0, 0)
            return      )
        
        readTable(spots, imageFileString)
        if readTable.errCode /= passed  then (
            printl("aligner3d.loadExperiment() error reading image spots file")
            parent(0, 0, 0)
            return      )
        
        parent(top(loci), top(spots), max( max(loci[*].color), max(spots[*].color) ) + 1)
        parent#2()
        
        chain_loaded = true
        done_restart = false
    }
    
    
    getNeighbors :: {
        
        params :: { l_num :: int, neighbor_p_cutoff :: double }
        
        code
        
        if trap(
            if top(args) /= 1  then throw(1)
            l_step = args[1]
            (params << ( { code, l_num = 10, neighbor_p_cutoff = .001 } : args))()
        ) /= passed  then (  printl("usage: aligner3d.getNeighbors(l_step [; l_num/neighbor_p_cutoff = values])"), return  )
        
        l_num = params.l_num
        neighbors[^numSpots*numColors*params.l_num]
        
        call("GetNeighbors", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz,
                colorRange, neighbors, l_step, params.neighbor_p_cutoff, lp)
    }
    
    
    scramble :: {
        
        scrambledSpots :: [*] { color :: int, rnd :: double }
        this.c1 :: int
        
        code
        
        scrambledSpots[^numSpots]
        scrambledSpots[*].color = spots[*].color
        
        for c1 in <1, numSpots>  &
            scrambledSpots[c1].rnd = random()

        sort(scrambledSpots, 2)
        
        spots[*].color = scrambledSpots[*].color
        parent#2()
    }
    
    
    restart :: {
        
        initProbs :: initF :: [] double
        w_bar :: double
        color_counter :: loopLocus :: loopSpot :: region_counter :: IP_counter :: IP_top :: num_regions :: CsNum :: init_counter :: int
        
        params :: {
            l_num :: l_step :: int
            n_skip_max :: int
            neighbor_p_cutoff :: n_skip_p_cutoff :: search_w_step :: set_w_tol :: double
            if_set_w :: bool        }

        params.lp := @lp, params.p_fn := @p_fn, params.p_fp := @p_fp

        params.initRegions :: {

            num_regions :: c1 :: int
            
            code
            
            num_regions = top(args)
            params.regions :: {}
            
            for c1 in <1, num_regions>  (
                params.regions[c1][1] := args[c1]
                if args[c1] < 2*lp  then params.regions[c1][2] := args[c1]
                else  params.regions[c1][2] := (2*lp*args[c1])^.5
                params.regions[c1][3] := (4/3)*pi*params.regions[c1][2]^3       )
        }
        
        region :: {  R_contour_length :: R_image_radius :: R_image_volume :: double  }     | was ':: region : {'
        regions :: [] region


        code
        
        if not chain_loaded  then (
            printl("Can't run restart() before loading a chain")
            return      )
        
        trap(remove params.Log)
        
        p_fn = p_fp = -1
        
        if trap( ;
            if top(args) /= 0  then exit
            
            lp = 50/.3, p_fp = 0
            params.if_set_w = false
            (params << ( { code, trap(remove regions), l_num = 10, l_step = 200, neighbor_p_cutoff = 1.e-5,
                        n_skip_p_cutoff = .01, n_skip_max = -1, fn_cost = 1, search_w_step = 1, set_w_tol = 1.e-2 }))()
            (params<<args)()
            
            if trap(
                num_regions = top(params.regions) + 1
                regions[^num_regions-1]
                regions = params.regions
                regions[+1] = { 0, 0, 0 }
            ) /= passed   then (
                num_regions = 1
                regions[^1] = { { 0, 0, 0 } }
        )   ) /= passed  then (
            printl("usage: aligner3d.restart([; lp/l_num/l_step/neighbor_p_cutoff/p_fn/p_fp/fn_cost/n_skip_p_cutoff/n_skip_max/",
                   "if_set_w/search_w_step/set_w_tol = values][, regions[*] :: {R_contour_length/R_image_radius/R_image_volume} ",
                   "or initRegions(R1, R2, ...)]  [, Log := @Z_1x/p/...])")
            return      )
        
        l_step = params.l_step
        
        if p_fn < 0 and p_fp < 0  then p_fp = 0
        
        if p_fn >= 0 and numSpots < (1 - p_fn) * numLoci  then &
            p_fn = 1 - numSpots/numLoci
        if p_fp >= 0 and numLoci < (1 - p_fp) * numSpots  then &
            p_fp = 1 - numLoci/numSpots
        
        if p_fn >= 0  then &
            p_fp = ( numSpots - (1 - p_fn) * numLoci ) / numSpots
        else  &
            p_fn = ( numLoci - (1 - p_fp) * numSpots ) / numLoci

        if p_fn < 0  then p_fn = 0
        else if p_fn > 1  then p_fn = 1

        if p_fp < 0  then p_fp = 0
        else if p_fp > 1  then p_fp = 1

        if params.n_skip_max >= 0  then &
            iterate.n_skip_max = params.n_skip_max
        else if p_fn > 0  then &
            iterate.n_skip_max = ceil(log(params.n_skip_p_cutoff) / log(p_fn))
        else  &
            iterate.n_skip_max = 0

        for loopSpot in <1, numSpots>  &
            sumSpotProbs[loopSpot] = overlapField[loopSpot] = gradOverlapField[loopSpot] = 0

        overlapField[numSpots+1] = gradOverlapField[numSpots+1] = 0
        
        for color_counter in <0, numColors-1>  (
            IP_top = colorRange[color_counter+1].high - colorRange[color_counter+1].low + 1
            initProbs[^IP_top], initF[^IP_top]
            for IP_counter in <1, IP_top>  (
                initF[IP_counter] = 1
                initProbs[IP_counter] = (1 - p_fn) / IP_top     )

            CsNum = 0
            for loopLocus in <1, numLoci>  (
            if loci[loopLocus].color == color_counter  then (
                p[loopLocus] =! initProbs
                sumLocusProbs[loopLocus] = 1 - p_fn
                CsNum = that + 1
            ))
            
            for IP_counter in <1, IP_top>  (
                sumSpotProbs[colorRange[color_counter+1].low + IP_counter - 1] = that + CsNum * initProbs[IP_counter]
        )   )
        
        Z_xN = Z_1x = sensitivity = p
        
        for loopLocus in <1, numLoci>  (
            Z[loopLocus] = dC_dZ[loopLocus] = 0
            Z_1x_norm[loopLocus] = Z_xN_norm[loopLocus] = sensitivity_norm[loopLocus] = 0     )
        
        l_num = params.l_num
        neighbors[^numSpots*numColors*params.l_num]
        
        call("GetNeighbors", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz,
                colorRange, neighbors, l_step, params.neighbor_p_cutoff, lp)
        
        (iterate.params << {
            code
            { step_size, exaggeration, line_min_param, max_convergence, opt_method } = { .01, 1, .1, .001, 3 }
        })()
        iterate.cum_iters = 0
        w_bar = 1
        
        iterate.if_log = false
        if trap( params.Log ) == passed  then (
            printl("*** Warning -- logging ***")
            iterate.if_log = true
            trap(remove iterate.Log)
            iterate.Log :: [0] [size(params.Log)/size(double)] double     )
        else  (
            trap(remove params.Log), trap(remove iterate.Log)
            params.Log :: iterate.Log :: [][] double     )

        iterate.C_history[^0]
        
        if params.if_set_w  then (
        for init_counter in <1, 2>  (
            
            overlapField[numSpots + 1] = optimize_1D(
                {
                    code
                    
                    overlapField[numSpots + 1] = args[1]
                    iterate(0; f_or_w = w)
                    
                    return occupancy() - (1 - p_fn)
                }
                
               code
               
               search_step = params.search_w_step
               tol = params.set_w_tol
               min = -1000, max = 1000      )
            
|*            if init_counter == 1  then (
                iterate.params.end_factor = optimize_1D(
                    {
                        c1 :: int, p_tot :: end_p_tot :: ef :: double
                        
                        code
                        
                        ef = args[1]
                        iterate(0, code, end_factor = ef, f_or_w = w)
                        
                        p_tot = end_p_tot = 0
                        for c1 in <1, numLoci>  (
                            p_tot = that + sumLocusProbs[c1]
                            if c1 <= iterate.n_skip_max+1 xor c1 >= numLoci-iterate.n_skip_max  then (
                                end_p_tot = that + sumLocusProbs[c1]
                        )   )
                        
                        if numLoci >= 2*(iterate.n_skip_max+1)  then &
                            return p_tot/numLoci - end_p_tot/iterate.n_skip_max/2
                        else  &
                            return end_p_tot/(2*(iterate.n_skip_max+1) - 2*numLoci) - p_tot/numLoci
                    }
                    
                   code
                   
                   search_step = params.search_w_step
                   tol = params.set_w_tol
                   min = -1000, max = 1000
            )   )
            
            else  ( *|
                
                for loopSpot in <1, numSpots>  &
                    overlapField[loopSpot] = -overlapField[numSpots+1]

                overlapField[numSpots+1] = 0
                
        ))  | )
        
        done_restart = true
    }
    
    
    iterate :: {
        
        params :: {
            step_size :: line_min_param :: max_convergence :: exaggeration :: double
            f_or_w :: opt_method :: int
            calcExact :: bool
            this.f := 1, this.w := 2              }
        params.exaggeration = @exaggeration
        C_history :: [*][2] double
        calc_count :: calc_time :: FE :: logZ :: fn_cost :: double
        max_iterations :: iters :: cum_iters :: iter_counter :: n_skip_max :: cd :: int
        iter_list :: { iters, (none::int) = 0 }
        restart.params.fn_cost := @fn_cost
        
        if_log :: bool
        
        
        code
        
        if not done_restart  then (
            printl("Can't run iterate() before loading a chain")
            return      )
        
        params.f_or_w = params.f
        params.calcExact = false
        if trap( ;
            { max_iterations } = args
            (params << args)()
        ) /= passed  then (
            printl("usage: aligner3d.iterate(max_iterations ; params from { opt_method, step_size, line_min_param, max_convergence } = values)")
            return      )
        
        calc_count = calc_time = 0
        iters = max_iterations
        C_history[^iters+1]
        
        if if_log  then (
            trap(remove Log)
            Log :: [iters+1] [size(restart.params.Log)/size(double)] double
            Log[1] =! restart.params.Log        )
        
|        for iter_counter in <1, 2>  (
 |           if iters == 0  then iter_counter = 2
            call("IterateProbs", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz, sumSpotProbs,
                            overlapField, gradOverlapField, colorRange, loci, mask, p, Z_1x, Z_xN, Z_1x_norm, Z_xN_norm, Z, dC_dZ,
                            sensitivity, sensitivity_norm, sumLocusProbs, neighbors, l_step, lp, n_skip_max,
                            p_fn, exaggeration, fn_cost, params.step_size, params.line_min_param, C_history, restart.params.Log, Log,
|                            calc_count, calc_time, FE, iter_list[iter_counter], params.max_convergence, params.opt_method, params.f_or_w,
                            calc_count, calc_time, FE, iter_list[1], params.max_convergence, params.opt_method, params.f_or_w,
                            params.calcExact, 0.) |pLR)
  |          if params.calcExact  then iter_counter = 2     )
        
        cum_iters = that + iters
        
        logZ = 0
        for cd in <1, numLoci>  &
            logZ = that + log(Z[cd]) + Z_1x_norm[cd] + Z_xN_norm[cd]
        logZ = that / numLoci
        
        for cd in <1, numSpots>  &
            logZ = that + sumSpotProbs[cd]*overlapField[cd]

        logZ = that + p_fn*overlapField[numSpots+1]         | should p_fn be multiplied by the number of loci??
        
        if if_log  then (
            Log[^iters+1]                       | in case iters < max_iterations
            saveTable(fullPath("ConvLog.txt"), Log)     )
        
        C_history[^iters+1]
        saveTable(fullPath("Cs.txt"), C_history)
        
        return new({ iters, C_history[iters+1], calc_count, calc_time, logZ })
    }
    
    
        | fix() and free() allow the user to dial in certain parts of a mapping while letting the align3d engine estimate the rest of the mapping probabilistically
    
	maskProbsTemplate :: {

        min :: max :: c1 :: int
		
		code
		
		if trap(
			if trap( min = args[1] ) /= passed  then (
                { min, max } = args[1]
                if max < 1 or max > numLoci  then throw(1)  )
            else  max = min

			if min < 1 or min > numLoci  then throw(1)
            
			if top(args) > args_top  then throw(1)
		) /= passed  then (  printl(usage_message), return  )
		
		for c1 in <min, max> &
            mask[c1] = mask_value
	}
    
    
    fix :: maskProbsTemplate : {
        args_top := 2
        usage_message := "usage: aligner3d.fix(locus # / { min spot #, max spot # } <= numLoci [, spot_num (0 for max)])"
        mask_value := 0
        
        spot_num :: spots_top :: c2 :: best_spot :: int
        spots :: [] double, max_spot_prob :: double
        
        code
        
        if top(args) == 2  then (
            if trap(spot_num = args[2]) /= passed  then (
                printl(usage_message, "  (warning -- mask has been changed)")
                return      )

            for c1 in <min, max>  (
                spots[*] =! p[c1]
                spots_top = top(spots)
                
                if spot_num <= spots_top  then (
                    if spot_num == 0  then (
                        max_spot_prob = 0, best_spot = 1
                        for c2 in <1, spots_top>  (
                        if spots[c2] > max_spot_prob  then (
                            max_spot_prob = spots[c2], best_spot = c2
                        ))
|*                        best_spot = max(spots; rtrn = index)*|       )

                    else  best_spot = spot_num

                    for c2 in <1, spots_top>  (
                        if c2  == best_spot  then spots[c2] = 1
                        else  spots[c2] = 0     )

                    p[c1] =! spots      )

                else  printl("fix() warning: spot_num > numSpots for locus # = ", c1)
        )   )
    }
    
    free :: maskProbsTemplate : {
        args_top := 1
        usage_message := "usage: aligner3d.free(min / { min, max } <= numLoci)"
        mask_value := 1
    }
    
    
    
    printProbs :: {
        
        probs :: [] double
        c1 :: the_color :: p0 :: pf :: int
        params :: { list :: group :: int, pZ := 0, s := 2 }
        the_list :: exp_list :: *
        if_exp :: bool
        exp_string :: string
        
        code
        
        if trap(
            if top(args) == 0  then (  p0 = 1, pf = numLoci  )
            else if top(args) == 1  then p0 = pf = args[1]
            else if top(args) == 2  then (  p0 = args[1], pf = args[2]  )
            else  throw(1)

            if p0 < 1 or pf < 1 or p0 > numLoci or pf > numLoci  then throw(2)
            
            params.list = 0, params.group = params.pZ
            (params<<args)()
            
            if_exp = false
            
            if params.group == params.pZ  then (
                if params.list == -1  then (  the_list = @Z_1x, exp_list = @Z_1x_norm, if_exp = true  )
                else if params.list == 0  then the_list = @p
                else if params.list == 1  then (  the_list = @Z_xN, exp_list = @Z_xN_norm, if_exp = true  )
                else  throw(1)      )
            else if params.group == params.s  then (  the_list = @sensitivity, exp_list = @sensitivity_norm, if_exp = true  )
            else  throw(1)
        ) /= passed  then (
            print("usage:  aligner3d.printProbs([lower bound [, upper bound]] [; list = { -1 (Z_1x) or 0 (probs) ")
            printl("or +1 (Z_xN)}, group = pZ/s/f/grad_f])")
            return      )
        
        for c1 in <p0, pf>  (
            probs[*] =! the_list[c1]
            the_color = loci[c1].color + 1
            
            print(c1, " (", colorRange[the_color].low, " -- ", colorRange[the_color].high, "):  ")
            if not if_exp  then sprint(probs)
            else  (
                print_string(exp_string, "x 10^", exp_list[c1]/log(10), " (", exp_list[c1], ")")
                sprint(probs, exp_string)
        )   )
        
        the_list = @nothing, exp_list = @nothing
    }
    
    
    exportProbs :: {
        
        all_probs :: [] { l :: x :: y :: z :: prob :: double, color :: int }
        probs :: [] double
        one_color_range :: { low :: high :: int }
        c1 :: c2 :: one_color :: int
        fileStr :: string


        code
        
        if trap(fileStr = args[1]) /= passed  then &
            fileStr = fullPath("AllProbs.txt")

        all_probs[^size(p)/size(double)]
        
        ap_top := 0
        
        for c1 in <1, numLoci>  (
            
            probs[*] =! p[c1]
            one_color = loci[c1].color + 1
            one_color_range = colorRange[one_color]
            
            for c2 in <one_color_range.low, one_color_range.high>  (
                ap_top = that + 1
                all_probs[ap_top] = { loci[c1].l, spots[c2].x, spots[c2].y, spots[c2].z,
                                    probs[c2 - one_color_range.low + 1], one_color }
        )   )
        
        saveTable(fileStr, all_probs)
    }
    
    
        | a silly routine to try to guess the best mapping
        | (doesn't take into account the no-overlap condition)
    
    bestMap :: {
        
        idx :: best_spot :: int
        probs :: [] double


        code
        
        if trap( { idx } = args ) /= passed  then (
            printl("usage:  image_spot = aligner3d.bestMap(index)")
            return      )
        else if idx < 1 or idx > numLoci   then &
            printl("bestMap() error:  index out of range")
        else if not done_restart  then &
            printl("bestMap() error:  haven't yet initialized p-values")

        probs[*] =! p[idx]
        best_spot = max(probs; rtrn = index) + colorRange[loci[idx].color+1].low - 1
        if max(probs) < 1. - sumLocusProbs[idx]  then best_spot = 0

        return new(best_spot)
    }
    
    
    occupancy :: {
        tot_prob :: double
        c1 :: the_color :: p0 :: pf :: int
        
        code
        
        if trap(
            if top(args) == 0  then (  p0 = 1, pf = numLoci  )
            else if top(args) == 1  then p0 = pf = args[1]
            else if top(args) == 2  then (  p0 = args[1], pf = args[2]  )
            else  throw(1)

            if p0 < 1 or pf < 1 or p0 > numLoci or pf > numLoci  then throw(2)
        ) /= passed  then (  printl("usage:  aligner3d.occupancy([lower bound [, upper bound]])"), return  )
        
        tot_prob = 0
        for c1 in <p0, pf>  &
            tot_prob = that + sumLocusProbs[c1]

        return new(tot_prob / (pf - p0 + 1))
    }
    
    
        | outputs a table of spot-to-spot 'distances' (free energies) suitable for a traveling-salesman solver
        | (this requires that the spots be equally spaced)
    
    saveTSP :: {
        
        c1 :: c2 :: int
        L :: GP :: double
        
        code
        
        if top(args) /= 0  then (  printl("usage: saveTSP()"), return 1  )
        if p_fn /= 0 or p_fp /= 0 or numLoci /= numSpots  then (
            printl("saveTSP():  p_fn and p_fp must equal 0")
            return 2            )

        if numLoci > 1  then (
            L = loci[2].l - loci[1].l
            for c1 in <2, numLoci-1>  (
            if loci[c1+1].l - loci[c1].l /= L  then (
                printl("saveTSP() error:  locus spacing is not equal")
                return 3
        )   ))
        
        TSP_table :: [numSpots] [numSpots] double
        
        for c1 in <1, numSpots>  (
            TSP_table[c1][c1] = 0
            for c2 in <1, c1-1>  (
                call("GaussianChain", spots[*].x, spots[*].y, spots[*].z, spots[*].dx, spots[*].dy, spots[*].dz, L, lp, c1, c2, GP)
                TSP_table[c1][c2] = TSP_table[c2][c1] = GP
        )   )
        
        saveTable(fullPath("TSP_table.txt"), TSP_table)
        
        remove TSP_table
    }
    
    
    entropyTemplate :: {
        
        result :: one_p :: double
        ps :: [] double
        order :: [*] int
        c1 :: c2 :: one_top :: l_bound :: u_bound :: int
        params :: {
            
            x_res :: y_res :: z_res :: double
            countFalseNegatives :: bool
        
            set_res :: {
                
                code
                
                if trap( { x_res } = args ) /= passed  then (
                    printl("usage: set_res(resolution)")
                    return      )

                y_res = z_res = x_res   }         }
        
        param_pass :: { params.x_res, params.y_res, params.z_res, params.countFalseNegatives }
        
        base := 2
        
        
        code
        
        if trap(
            if top(args) == 0  then (  l_bound = 1, u_bound = numLoci  )
            else if top(args) == 1  then l_bound = u_bound = args[1]
            else if top(args) == 2  then (  l_bound = args[1], u_bound = args[2]  )
            else  throw(1)
            
            param_pass = { 0, 0, 0, true }
            (params << args)()
        ) /= passed  then (
            printl("usage:  result = aligner3d.", name, "( [ l_bound [, u_bound ] ] ; x_res/y_res/z_res/countFalseNegatives = values or set_res(resolution))")
            return      )

        get_order()
        
        call("Entropy", spots[*].x, spots[*].y, spots[*].z, p[<l_bound, u_bound>],
                loci[<l_bound, u_bound>].color, colorRange, order, param_pass, result)
        
        return new(result/log(base)/numLoci)
    }
    
    
    entropy :: entropyTemplate : { name := "entropy", order[^0], get_order :: {} }
    
	
    this(0, 0, 0)
    
    
    
    code
    
    if trap(
        if top(args) /= 3  then throw(1)
        
        (numLoci :: int) = args[1]
        (numSpots :: int) = args[2]
        (numColors :: int) = args[3]
    ) /= passed  then (  printl("usage:  aligner3d(numLoci, numSpots, numColors)"), return  )
    
    spots[^numSpots]
    loci[^numLoci]
    
    colorRange[^numColors]
    
    p[^numLoci]
    Z_1x[^numLoci]
    Z_xN[^numLoci]
    sensitivity[^numLoci]
    overlapField[^numSpots+1]
    gradOverlapField[^numSpots+1]
    Z_1x_norm[^numLoci]
    Z_xN_norm[^numLoci]
    Z[^numLoci]
    dC_dZ[^numLoci]
    sensitivity_norm[^numLoci]
    
    sumLocusProbs[^numLoci]
    mask[^numLoci]
    
    sumSpotProbs[^numSpots]
	
    if numLoci > 0  then mask[<1, numLoci>] = 1

    
    
    code
    
    sort(spots, 7)
    
    current_color = 0
    colorRange[1].low = 1
    for cs in <1, numSpots>  (
        if spots[cs].color /= current_color  then (
            colorRange[current_color+1].high = cs-1
            current_color = that + 1
            colorRange[current_color+1].low = cs
            cs = that - 1
    )   )
    colorRange[current_color+1].high = numSpots
    for current_color in <current_color+2, numColors>  &
        colorRange[current_color] = { numSpots+1, numSpots }
}





| 1D root finder for sign(f) = sign(x-x0)

optimize_1D :: {
    
    low :: high :: mid :: to_push :: other :: double
    params :: {  search_step :: tol :: min :: max :: double  }
    
    
    code
    
    if trap(
        if top(args) /= 1  then throw(1)
        params = { 1, 1e-4, -1e4, 1e4 }
        (params<<args)()
    ) /= passed  then (
        printl("usage:  optimize_1D(f (returns > 0 (too high) or < 0 (too low)) [ ; params from search_step/tol/min/max = values])")
        return      )
    
    
        | first bracket the root
    
    low = high = 0
    tol := params.tol
    push_distance :: double
    
    if args[1](low) < 0  then &
        to_push = @high, other = @low, push_distance = 1
    else &
        to_push = @low, other = @high, push_distance = -1

    loop
        other = to_push
        to_push = that + push_distance * params.search_step
        push_distance = that * 2
    until push_distance * args[1](to_push) >= 0 or push_distance < params.min or push_distance > params.max
    
    
        | iterate the root finder
    
    loop
        mid = (low + high) / 2
        
        if args[1](mid) < 0  then low = mid
        else  high = mid
    until high - low < params.tol
    
    return (low + high)/2
}
